% est‰mme ihme "underfull \hbox (badness 10000)" -varoitukset (ei hajua mist‰ tulevat)
\hbadness=10000

% nopsa pikkuluokkakaavioiden lis‰ysmakro
% pois figuren sis‰lt‰ niin kuvat tulee minne pit‰‰kin, feikataan kuvanumerointi ja kuvateksti
\newcommand{\insertdia}[1] {
	% \begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.33]{dia/#1.eps}
	% \caption{#1}
	\refstepcounter{figure}
	\label{fig:#1}
	\nopagebreak \\ \medskip Figure \arabic{figure}: #1 \\
	\addcontentsline{lof}{figure}{#1}
	\end{center}
	% \end{figure}
}

\section{Introduction}
\label{sec:intro}

Blablabla balalaalllblaaaaaaa aaaaarrggrgghh.


\section{Overview of changes from Design document}
\label{sec:overview}

The big picture.


\section{Specific changes from Design document}
\label{sec:changes}

Here we describe how the implementation/production differs from that planned in Design document.


\subsection{Data classes and methods}


\subsubsection{Project data}

\insertdia{project-graph}

Responsible for holding all the measurement data and controlling the SQUID. All of these classes were produced according to plans and there were no significant changes. Things such as susceptibility and some other data from the measurements was added. The way that the mathematical calculations are made, had some changes, such as the holder and background noise corrections.


\subsubsection{Squid interface}

\insertdia{squid-graph}

Squid Interface offers the Project class an interface to safely control the SQUID magnetometer. The Squid class holds three classes that handle communication to to three separate parts of the SQUID (Handler, Degausser and Magnetometer).

Classes are Squid, Handler, Magnetometer, Degausser.

These were not desinged well because it was hard to know how exactly we should use Squid at the time. Lots of changes were made and many methods were removed and added. Private status String is not used in any class and messageBuffer is not used like vise. Messages are catch on private SynchronousQueue<String> answerQueue = new SynchronousQueue<String>() variable and there is private boolean waitingForMessage variable indicating are we waiting any message from equipment.

\textbf{Handler}: Biggest change here is that we use WorkingQueue here. And EstimatedMovement are calculated here too. Many of the methods are change and most are removed or not used like planned.

\textbf{Methods not used or removed}:

poll(take)Message()

setPositionRegister(int r)

setPosition(int p)

setSteps(int s)

stop()

setBaseSpeed(int b)

setHoldTime(int h)

setCrystalFrequence(int cf)

getStatus()

\textbf{Methods added or modified}:

public int getEstimatedPosition() : return where is handler.

public int getEstimatedRotation() : return rotation of handler.

public boolean isMoving() : tells if we are moving.

public boolean isRotating() : tells if we are rotating.

public void moveToLeftLimit() : starts moving to left limit.

public void moveToRightLimit() : starts moving to right limit.

protected void moveSteps(int steps, int velocity) throws SerialIOException : moves steps as commanded.

protected void moveToPosition(int position) throws SerialIOException : moves handler to position, relative to home.

protected void seekHome() throws SerialIOException : seeks home position.

protected void selectMovement() throws SerialIOException : sets Handler on moving phase.

protected void selectRotation() throws SerialIOException : sets Handler on rotating phase.

protected void setPosition(int position) : sets position for EstimatedMovement.

protected void setRotation(int rotationSteps) : sets  rotation for EstimatedMovement.

protected void setUp() : sets Handler online.

protected void slewToLimit(boolean toRight) throws SerialIOException : sets Handler to go limit.

\textbf{Degausser}: Pretty much the same as planned. There is added blockingWrite(String command) that waits that command is sended, which is known when degausser answers it back.

\textbf{Magnetometer}: Pretty much the same but getter commands are not used.

\subsubsection{Squid emulator}

Squid Emulator is separate from the rest of the program and it is used only for testing that the Squid Interface works correctly. Biggest change was that this wasnt developed much and its not working as planned. Mainly was used to test that commands are sended correctly and Squid Interface gets answers.


\subsubsection{Serial communication}

SerialIO and classes related to it takes care of the harware layer of serial communication. Using these classes the program communicates with the Degausser, Samplehandler and Magnetometer. SerialIO represents one serial port and when it's created it reserves the port to itself. SerialProperties class includes all the configuration data for the serial port.


\subsubsection{Global settings}

Global properties that are used all around the program. There were many properties added to the Settings class. Not all of the methods are documented, so that should be done. All methods were converted to be static.


\subsubsection{Utilities}

Utility classes that are used in the program, but do not fit any of the other packages. There were a couple of classes added to the ikayaki.util package. The new classes are ComponentPrinter for printing, DocumentUtilities for reading and writing XML, LoggerPrintStream for adding timestamps to System.err and copying the output to a file, SerialProxy for monitoring the communication between two serial ports (use virtual serial ports to redirect the old program's communication through SerialProxy this way: Program -> Virtual COM -> SerialProxy -> Real COM -> SQUID Hardware).


\subsection{GUI classes and methods}


\subsubsection{Generic GUI components}

There were no changes to ProjectComponent.


\subsubsection{Main window}

\insertdia{main-view-panel-graph}

Basically the same as was designed, but there were many methods added.


\subsubsection{Configuration window}

Separate window which is opened from menubar and it updates settings for Squid interface. Used usually only when system is installed to setup it. If there is something changed, program should be restarted as there is no quarantee that they affect directly.


\subsubsection{Project Explorer}

Nothing much here; some internal private field renames. Oh and a lot more stuff than planning suggests :)

ProjectExplorerTable is now its own class (as Calibration uses it too), and ProjectExplorerPopupMenu is its inner class. Also has inner class ProjectExplorerTableModel, which, unlike normally (as in the standard way), is quite empty and most of the stuff is in ProjectExplorerTable. Uses StyledWrapper for table row background colors (and Calibration boldface-reminder).

NewProjectPanel is inner class of ProjectExplorerPanel.


\subsubsection{Calibration}

Uses ProjectExplorerTable, which makes Calibration.java really short.


\subsubsection{Project information}

Contains and allows the editing of the basic information of a sample. All plans were dumped and the classes were programmed XP-style.


\subsubsection{Sequence and measurement data}

Contains and allows the editing of the measurement sequence. All plans were dumped and the classes were programmed XP-style.


\subsubsection{Measurement details}

Contains the details of the selected row in the measurement sequence. All plans were dumped and the classes were programmed XP-style.


\subsubsection{Measurement controls}

Sadly, ManualControlsPanel had to go into MagnetometerStatusPanel as an inner class, since they share some data and move-radiobuttons.

MagnetometerStatusPanel's updateStatus takes no parameters, as it asks position and rotation directly from Handler. Also, status image is updated at all times once in 50 ms (positions asked with getEstimatedPosition and getEstimatedRotation in Handler).

Here too, a lot more stuff than what planning imply.

ManualControlsPanel's manual control components are disabled whenever there's \textit{any} Squid action, to keep those fragile equipments from messing up.


\subsubsection{Graphs}

Graph panels visualize the measurement data. MeasurementGraphsPanel listens to MeasurementEvents to update the measurement data in plots. AbstractPlot is an abstract class which implements all the general features of graph plots. IntensityPlot and StereoPlot extend the functionality of AbstractPlot and implement their special drawing features accordingly.


\section{TODO-list from source code}
\label{sec:todo}

\input{todolist}


\section{Improvement suggestions}
\label{sec:improv}

What's left for the program to make it perfect :)


\subsection{...}


\subsection{Porting to linux}
