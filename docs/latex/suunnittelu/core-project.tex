
\beginClass{Project}
\classPackage{ikayaki}
\classDeclaration{public class Project}
\classCreatedBy{ProjectExplorerPanel}
\classUses{MeasurementSequence}
\classUses{MeasurementStep}
\classUses{MeasurementResult}
\classUses{MeasurementValue}
\classUses{Squid}
\classUses{RunQueue}
\classUses{ProjectEvent}
\classUses{MeasurementEvent}
\classComment{
	Represents a measurement project file. Project is responsible for managing and storing the data that is recieved from the magnetometer measurements. Any changes made to the project will be written to file regularly (autosave).
	
	Project is responsible for controlling the magnetometer through the SQUID API. Controlling the SQUID will be done in a private worker thread. Only one project at a time may access the SQUID.
	
	All operations are thread-safe.
}
\classPatterns{Facade}
\classEvent{On property change}{Autosaving will be invoked and the project written to file after a short delay.}
\classEvent{On measurement started/ended/paused/aborted}{ProjectEvent will be fired to all project listeners.}
\classEvent{On measurement subphase started/completed}{MeasurementEvent will be fired to all measurement listeners.}
\classEvent{On declination/inclination/volume changed}{The updated transformation matrix will be applied to all measurements and a ProjectEvent will be fired to all project listeners.}
\closeClass

\beginField{projectCache}
\fieldDeclaration{private static Hashtable<File,Project> projectCache}
\fieldComment{
	Caches the created and loaded Project objects to make sure that no more than one object will be created for each physical file.
}
\closeField

\beginField{file}
\fieldDeclaration{private File file}
\fieldComment{
	Location of the project file in the local file system. Autosaving will save the project to this file.
}
\closeField

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
	Type of the measurement project. This will affect which features of the project are enabled and disabled.
}
\closeField

\beginField{state}
\fieldDeclaration{private State state}
\fieldValue{IDLE}
\fieldComment{
	Current state of the measurements. If no measurement is running, then state is IDLE. Only one measurement may be running at a time.
}
\closeField

\beginField{squid}
\fieldDeclaration{private Squid squid}
\fieldValue{null}
\fieldComment{
	Pointer to the SQUID device interface, or null if this project is not its owner.
}
\closeField

\beginField{properties}
\fieldDeclaration{private Properties properties}
\fieldComment{
	Custom properties of this project stored in a map. The project is not interested in what properties are stored; it only saves them.
}
\closeField

\beginField{sequence}
\fieldDeclaration{private MeasurementSequence sequence}
\fieldComment{
	Measurement sequence of this project. In the beginning are all completed measurement steps, and in the end are planned measurement steps. Completed measurements may NOT be deleted.
}
\closeField

\beginField{strike}
\fieldDeclaration{private double strike}
\fieldValue{0.0}
\fieldComment{
	Strike of the sample. Will be used to create the transform matrix.
}
\closeField

\beginField{dip}
\fieldDeclaration{private double dip}
\fieldValue{0.0}
\fieldComment{
	Dip of the sample. Will be used to create the transform matrix.
}
\closeField

\beginField{sampleType}
\fieldDeclaration{private SampleType sampleType}
\fieldValue{CORE}
\fieldComment{
	Type of the sample. Will be used to create the transform matrix.
}
\closeField

\beginField{transform}
\fieldDeclaration{private Matrix3d transform}
\fieldValue{new Matrix3d()}
\fieldComment{
	Matrix for correcting the sample's orientation. The matrix will be updated whenever the strike, dip or sampleType is changed. After that the updated matrix will be applied to all measurements.
}
\closeField

\beginField{mass}
\fieldDeclaration{private double mass}
\fieldValue{-1.0}
\fieldComment{
	Mass of the sample, or a negative value if no mass is defined.
}
\closeField

\beginField{volume}
\fieldDeclaration{private double volume}
\fieldValue{-1.0}
\fieldComment{
	Volume of the sample, or a negative value if no volume is defined.
}
\closeField

\beginField{currentStep}
\fieldDeclaration{private MeasurementStep currentStep}
\fieldValue{null}
\fieldComment{
	Current measurement step, or null if no measurement is running.
}
\closeField

\beginField{listenerList}
\fieldDeclaration{private EventListenerList listenerList}
\fieldValue{new EventListenerList()}
\fieldComment{
	Listeners for this project.
}
\closeField

\beginField{autosaveQueue}
\fieldDeclaration{private RunQueue autosaveQueue}
\fieldValue{new RunQueue(500, true)}
\fieldComment{
	Scheduler for automatically writing the modified project to file after a short delay.
}
\closeField

\beginMethod{createCalibrationProject(File)}
\methodDeclaration{public static Project createCalibrationProject(File file)}
\methodComment{
	Creates a calibration project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createAFProject(File)}
\methodDeclaration{public static Project createAFProject(File file)}
\methodComment{
	Creates an AF project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createThellierProject(File)}
\methodDeclaration{public static Project createThellierProject(File file)}
\methodComment{
	Creates a thellier project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createThermalProject(File)}
\methodDeclaration{public static Project createThermalProject(File file)}
\methodComment{
	Creates a thermal project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createProject(File,Type)}
\methodDeclaration{private static Project createProject(File file, Type type)}
\methodComment{
	Creates a project file of the specified type. Ensures that the project file has been written to disk. Adds the created Project object to projectCache.
}
\methodParam{file}{path for the new project file.}
\methodParam{type}{type of the project.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{loadProject(File)}
\methodDeclaration{public static Project loadProject(File file)}
\methodComment{
	Loads a saved project file. If the file has already been loaded, will return a reference to the existing Project object.
}
\methodParam{file}{project file to be loaded.}
\methodReturn{the loaded project, or null if file is not a valid project file or it was not readable.}
\closeMethod

\beginMethod{closeProject(Project)}
\methodDeclaration{public static boolean closeProject(Project project)}
\methodComment{
	Ensures that the project file is saved and frees the resources taken by the project. A project should not be used after it has been closed -- any further use of the object is undefined (probably will create NullPointerExceptions). The closed project is removed from the projectCache. A project can not be closed if it has a measurement running.
}
\methodParam{project}{project to be closed.}
\methodReturn{true if the project has been closed, false if a measurement is running and the project can not be closed.}
\methodThrows{NullPointerException}{if the project is null.}
\closeMethod

\beginMethod{Project(File,Type)}
\methodDeclaration{private Project(File file, Type type)}
\methodComment{
	Creates a new project of the specified type. This constructor will not write to file, so the user of this method should call the saveNow() method after the project is initialized.
}
\methodParam{file}{path for this project file. The file should exist (may be empty) and be writable, but this constructor will not check it.}
\methodParam{type}{type of the project.}
\methodReturn{the created project.}
\closeMethod

\beginMethod{Project(File,Document)}
\methodDeclaration{private Project(File file, Document document)}
\methodComment{
	Creates a new project from the specified document. This constructor will assume that the specified file is the same from which the document was read.
}
\methodParam{file}{path for this project file. The file should be the same from which document was read and be writable, but this constructor will not check it.}
\methodParam{document}{the document from which this project will be created.}
\methodReturn{the created project.}
\methodThrows{IllegalArgumentException}{if the document was not in the right format.}
\closeMethod

\beginMethod{getDocument()}
\methodDeclaration{public synchronized Document getDocument()}
\methodComment{
	Exports this project to a DOM document.
}
\closeMethod

\beginMethod{save()}
\methodDeclaration{public synchronized void save()}
\methodComment{
	Invokes autosaving. This method will schedule a saving operation and return. After this method has not been called for a short while, the project will be written to file.
}
\closeMethod

\beginMethod{saveNow()}
\methodDeclaration{public void saveNow()}
\methodComment{
	Writes this project to its project file and waits for the operation to complete.
	
	(NOTE: Synchronizing is done inside the method)
}
\methodThrows{IOException}{if there was an error when writing to file.}
\closeMethod

\beginMethod{getFile()}
\methodDeclaration{public synchronized File getFile()}
\methodComment{
	Returns the project file of this project.
}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public synchronized Type getType()}
\methodComment{
	Returns the type of this project.
}
\closeMethod

\beginMethod{getState()}
\methodDeclaration{public synchronized State getState()}
\methodComment{
	Returns the current measurement state of this project.
}
\closeMethod

\beginMethod{getName()}
\methodDeclaration{public synchronized String getName()}
\methodComment{
	Returns the name of this project. The name is equal to the name of the project file without the file extension.
}
\closeMethod

\beginMethod{getTimestamp()}
\methodDeclaration{public synchronized Date getTimestamp()}
\methodComment{
	Returns the timestamp of the last completed measurement. This is usually less than the last modified date of the file, because this is not affected by changing the project's properties.
}
\closeMethod

\beginMethod{getSquid()}
\methodDeclaration{private synchronized Squid getSquid()}
\methodComment{
	Returns the Squid if this project is its owner, otherwise returns null.
	
	(NOTE: Make this method public? Or return a Proxy (see design patterns), so others can know where the handler is moving but not control it?)
}
\closeMethod

\beginMethod{setSquid(Squid)}
\methodDeclaration{public synchronized boolean setSquid(Squid squid)}
\methodComment{
	Sets this project the owner of the Squid. Uses the setOwner() method of the specified Squid.
	
	Only one project may own the Squid at a time. The Squid must be first detached with "setSquid(null)" from its owner before it can be given to another project. Detaching the Squid is possible only when the project's state is IDLE.
}
\methodParam{squid}{pointer to the SQUID interface, or null to detach this project from it.}
\methodReturn{true if the operation was completed, false if the Squid has another owner or a measurement is running (in which case nothing was changed).}
\closeMethod

\beginMethod{getProperty(String)}
\methodDeclaration{public synchronized String getProperty(String key)}
\methodComment{
	Returns a project information property.
}
\methodParam{key}{the key which is associated with the property.}
\methodReturn{the specified property, or an empty String if the property is not set.}
\closeMethod

\beginMethod{setProperty(String,String)}
\methodDeclaration{public synchronized void setProperty(String key, String value)}
\methodComment{
	Sets a project information property.
}
\methodParam{key}{the key which is associated with the property.}
\methodParam{value}{new value for the property, or null to remove the property.}
\closeMethod

\beginMethod{getStrike()}
\methodDeclaration{public synchronized double getStrike()}
\methodComment{
	Returns the strike of the sample.
}
\closeMethod

\beginMethod{setStrike(double)}
\methodDeclaration{public synchronized void setStrike(double strike)}
\methodComment{
	Sets the strike of the sample and calls updateTransforms().
}
\closeMethod

\beginMethod{getDip()}
\methodDeclaration{public synchronized double getDip()}
\methodComment{
	Returns the dip of the sample.
}
\closeMethod

\beginMethod{setDip(double)}
\methodDeclaration{public synchronized void setDip(double dip)}
\methodComment{
	Sets the dip of the sample and calls updateTransforms().
}
\closeMethod

\beginMethod{getSampleType()}
\methodDeclaration{public synchronized SampleType getSampleType()}
\methodComment{
	Returns the type of the sample.
}
\closeMethod

\beginMethod{setSampleType(SampleType)}
\methodDeclaration{public synchronized void setSampleType(SampleType sampleType)}
\methodComment{
	Sets the type of the sample and calls updateTransforms().
}
\methodThrows{NullPointerException}{if sampleType is null.}
\closeMethod

\beginMethod{getTransform()}
\methodDeclaration{synchronized Matrix3d getTransform()}
\methodComment{
	Returns the current transformation matrix for the sample. For performance reasons, this method returns a reference to the internal data structure and not a copy of it.
	
	WARNING!!! Absolutely NO modification of the data contained in this matrix should be made -- if any such manipulation is necessary, it should be done on a copy of the matrix returned rather than the matrix itself.
}
\methodReturn{reference to the transformation matrix.}
\closeMethod

\beginMethod{updateTransforms()}
\methodDeclaration{private synchronized void updateTransforms()}
\methodComment{
	Recalculates the transformation matrix and updates all measurements. This method is called automatically by the setStrike(), setDip() and setSampleType() methods.
}
\closeMethod

\beginMethod{getMass()}
\methodDeclaration{public synchronized double getMass()}
\methodComment{
	Returns the mass of the sample.
}
\methodReturn{mass of the sample, or a negative number if no mass is specified.}
\closeMethod

\beginMethod{setMass(double)}
\methodDeclaration{public synchronized void setMass(double mass)}
\methodComment{
	Sets the mass of the sample.
}
\methodParam{mass}{mass of the sample, or a negative number to clear it.}
\closeMethod

\beginMethod{getVolume()}
\methodDeclaration{public synchronized double getVolume()}
\methodComment{
	Returns the volume of the sample.
}
\methodReturn{volume of the sample, or a negative number if no volume is specified.}
\closeMethod

\beginMethod{setVolume(double)}
\methodDeclaration{public synchronized void setVolume(double volume)}
\methodComment{
	Sets the volume of the sample.
}
\methodParam{volume}{volume of the sample, or a negative number to clear it.}
\closeMethod

\beginMethod{addProjectListener(ProjectListener)}
\methodDeclaration{public synchronized void addProjectListener(ProjectListener l)}
\methodComment{
	Adds a ProjectListener to the project.
}
\methodParam{l}{the listener to be added.}
\closeMethod

\beginMethod{removeProjectListener(ProjectListener)}
\methodDeclaration{public synchronized void removeProjectListener(ProjectListener l)}
\methodComment{
	Removes a ProjectListener from the project.
}
\methodParam{l}{the listener to be removed}
\closeMethod

\beginMethod{fireProjectEvent(ProjectEvent.Type)}
\methodDeclaration{private synchronized void fireProjectEvent(ProjectEvent.Type type)}
\methodComment{
	Notifies all listeners that have registered for ProjectEvents.
}
\methodParam{type}{type of the event.}
\closeMethod

\beginMethod{addMeasurementListener}
\methodDeclaration{public synchronized void addMeasurementListener(MeasurementListener l)}
\methodComment{
	Adds a MeasurementListener to the project.
}
\methodParam{l}{the listener to be added.}
\closeMethod

\beginMethod{removeMeasurementListener}
\methodDeclaration{public synchronized void removeMeasurementListener(MeasurementListener l)}
\methodComment{
	Removes a MeasurementListener from the project.
}
\methodParam{l}{the listener to be removed}
\closeMethod

\beginMethod{fireMeasurementEvent(MeasurementStep,MeasurementEvent.Type)}
\methodDeclaration{private synchronized void fireMeasurementEvent(MeasurementStep step, MeasurementEvent.Type type)}
\methodComment{
	Notifies all listeners that have registered for MeasurementEvents.
}
\methodParam{step}{the measurement step that has generated the event.}
\methodParam{type}{the type of the event.}
\closeMethod

\beginMethod{addSequence(MeasurementSequence}
\methodDeclaration{public synchronized void addSequence(MeasurementSequence sequence)}
\methodComment{
	Appends a sequence to this project's sequence. Only the stepValues will be copied from the specified sequence and added as new steps to this project.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{sequence}{the measurement sequence to be added.}
\methodThrows{NullPointerException}{if sequence is null.}
\closeMethod

\beginMethod{copySequence(int,int)}
\methodDeclaration{public synchronized MeasurementSequence copySequence(int start, int end)}
\methodComment{
	Returns a copy of this project's sequence. Only the stepValues will be copied from this project's sequence. The returned sequence will have no name.
}
\methodParam{start}{index of the first step in the sequence.}
\methodParam{end}{index of the last step in the sequence. If end < start, then an empty sequence will be returned.}
\methodReturn{copy of the sequence with only stepValues and no results.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (start < 0 || end >= getSteps()).}
\closeMethod

\beginMethod{addStep(MeasurementStep)}
\methodDeclaration{public synchronized void addStep(MeasurementStep step)}
\methodComment{
	Appends a step to this project's sequence. Only the stepValue will be copied from the specified step and added as new steps to this project.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{step}{the measurement step to be added.}
\methodThrows{NullPointerException}{if step is null.}
\closeMethod

\beginMethod{addStep(int,MeasurementStep)}
\methodDeclaration{public synchronized void addStep(int index, MeasurementStep step)}
\methodComment{
	Adds a step to the specified index of this project's sequence. Only the stepValue will be copied from the specified step and added as new steps to this project.
	
	The index must be such, that the indices of the completed measurements will not change.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{index}{the index to which the step will be added.}
\methodParam{step}{the measurement step to be added.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < getCompletedSteps() || index > getSteps()).}
\methodThrows{NullPointerException}{if step is null.}
\closeMethod

\beginMethod{removeStep(int)}
\methodDeclaration{public synchronized void removeStep(int index)}
\methodComment{
	Removes a step from this project's sequence. Completed measurements can not be removed.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{index}{the index of the step to be removed.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < getCompletedSteps() || index >= getSteps()).}
\closeMethod

\beginMethod{removeStep(int,int)}
\methodDeclaration{public synchronized void removeStep(int start, int end)}
\methodComment{
	Removes a series of steps from this project's sequence. Completed measurements can not be removed.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{start}{the first index to be removed.}
\methodParam{end}{the last index to be removed. If end < start, no steps will be removed.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (start < getCompletedSteps() || end >= getSteps()).}
\closeMethod

\beginMethod{getSteps()}
\methodDeclaration{public synchronized int getSteps()}
\methodComment{
	Returns the number of steps in this project.
}
\closeMethod

\beginMethod{getCompletedSteps()}
\methodDeclaration{public synchronized int getCompletedSteps()}
\methodComment{
	Returns the number of completed steps in this project. Steps that are currently being measured, are included in this count. Completed steps are always first in the sequence.
}
\closeMethod

\beginMethod{getStep(int)}
\methodDeclaration{public synchronized MeasurementStep getStep(int index)}
\methodComment{
	Returns a step from the sequence.
}
\methodParam{index}{the index of the step.}
\methodReturn{the specified step.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < 0 || index >= getSteps()).}
\closeMethod

\beginMethod{getCurrentStep()}
\methodDeclaration{public synchronized MeasurementStep getCurrentStep()}
\methodComment{
	Returns the step that is currently being measured.
}
\methodReturn{the currently measured step, or null if no measurement is active.}
\closeMethod

\beginMethod{getValue(int,MeasurementValue)}
\methodDeclaration{public synchronized <A> A getValue(int step, MeasurementValue<A> algorithm)}
\methodComment{
	Calculates and returns a value from a measurement step. The specified MeasurementValue's algorithm will be used and the results returned.
}
\methodParam{step}{the measurement step from which the value is calculated.}
\methodParam{algorithm}{the algorithm for calculating the desired value.}
\methodReturn{the value returned by the algorithm, or null if it was not possible to calculate it.}
\methodThrows{NullPointerException}{if algorithm is null.}
\closeMethod

\beginMethod{isDegaussingEnabled()}
\methodDeclaration{public synchronized boolean isDegaussingEnabled()}
\methodComment{
	Tells whether it is allowed to use the degausser in this project. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isSequenceEditEnabled()}
\methodDeclaration{public synchronized boolean isSequenceEditEnabled()}
\methodComment{
	Tells whether it is allowed to edit the sequence. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isManualControlEnabled()}
\methodDeclaration{public synchronized boolean isManualControlEnabled()}
\methodComment{
	Tells whether it is allowed to control the Squid manually. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isAutoStepEnabled()}
\methodDeclaration{public synchronized boolean isAutoStepEnabled()}
\methodComment{
	Tells whether it is allowed to do an auto step measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isSingleStepEnabled()}
\methodDeclaration{public synchronized boolean isSingleStepEnabled()}
\methodComment{
	Tells whether it is allowed to do a single step measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isPauseEnabled()}
\methodDeclaration{public synchronized boolean isPauseEnabled()}
\methodComment{
	Tells whether it is possible to pause the measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isAbortEnabled()}
\methodDeclaration{public synchronized boolean isAbortEnabled()}
\methodComment{
	Tells whether it is possible to abort the measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{doAutoStep()}
\methodDeclaration{public synchronized boolean doAutoStep()}
\methodComment{
	Starts an auto step measurement. Will do nothing if isAutoStepEnabled() is false.
	
	The measurement will run in its own thread, and this method will not wait for it to finish.
}
\methodReturn{true if the measurement was started, otherwise false.}
\closeMethod

\beginMethod{doSingleStep()}
\methodDeclaration{public synchronized boolean doSingleStep()}
\methodComment{
	Starts a single step measurement. Will do nothing if isSingleStepEnabled() is false.
	
	The measurement will run in its own thread, and this method will not wait for it to finish.
}
\methodReturn{true if the measurement was started, otherwise false.}
\closeMethod

\beginMethod{doPause()}
\methodDeclaration{public synchronized boolean doPause()}
\methodComment{
	Pauses the currently running measurement. A paused measurement will halt after it finishes the current measurement step. Will do nothing if isPauseEnabled() is false.
	
	This method will notify the measurement thread to pause, but will not wait for it to finish.
}
\methodReturn{true if the measurement will pause, otherwise false.}
\closeMethod

\beginMethod{doAbort()}
\methodDeclaration{public synchronized boolean doAbort()}
\methodComment{
	Aborts the currently running measurement. An aborted measurement will halt immediately, leave the handler where it was and enable manual control. Will do nothing if isAbortEnabled() is false.
	
	This method will notify the measurement thread to abort, but will not wait for it to finish.
}
\methodReturn{true if the measurement will abort, otherwise false.}
\closeMethod


\beginClass{Project.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The type of the project. Options are CALIBRATION, AF, THELLIER and THERMAL.
}
\closeClass


\beginClass{Project.State}
\classPackage{ikayaki}
\classDeclaration{public enum State}
\classComment{
	The state of the project's measurements. Options are IDLE, MEASURING, PAUSED, ABORTED.
}
\closeClass


\beginClass{MeasurementSequence}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementSequence}
\classCreatedBy{Project}
\classUses{MeasurementStep}
\classComment{
	A list of measurement steps. Steps can be added or removed from the sequence.
	
	All operations are thread-safe.
}
\closeClass

\beginField{name}
\fieldDeclaration{private String name}
\fieldValue{null}
\fieldComment{
	Name of the sequence or null if it has no name.
}
\closeField

\beginField{steps}
\fieldDeclaration{private List<MeasurementStep>}
\fieldValue{new ArrayList<MeasurementStep>()}
\fieldComment{
	The measurement steps of this sequence.
}
\closeField

\beginMethod{MeasurementSequence()}
\methodDeclaration{public MeasurementSequence()}
\methodComment{
	Creates an empty sequence with no name.
}
\methodReturn{the created sequence.}
\closeMethod

\beginMethod{MeasurementSequence(String)}
\methodDeclaration{public MeasurementSequence(String name)}
\methodComment{
	Creates an empty sequence with the specified name.
}
\methodParam{name}{name of the sequence.}
\methodReturn{the created sequence.}
\closeMethod

\beginMethod{MeasurementSequence(Element)}
\methodDeclaration{public MeasurementSequence(Element import)}
\methodComment{
	Creates a sequence from the specified element.
}
\methodParam{import}{the element from which this sequence will be created.}
\methodReturn{the created sequence.}
\methodThrows{IllegalArgumentException}{if the element was not in the right format.}
\closeMethod

\beginMethod{MeasurementSequence(Element,Project)}
\methodDeclaration{public MeasurementSequence(Element import, Project project)}
\methodComment{
	Creates a sequence from the specified element for a project.
}
\methodParam{import}{the element from which this sequence will be created.}
\methodParam{project}{the project whose sequence this will be. Needed for importing the measurement steps correctly.}
\methodReturn{the created sequence.}
\methodThrows{IllegalArgumentException}{if the element was not in the right format.}
\closeMethod

\beginMethod{getElement()}
\methodDeclaration{public synchronized Element getElement()}
\methodComment{
	Exports this sequence to a DOM element.
}
\closeMethod

\beginMethod{getName()}
\methodDeclaration{public synchronized String getName()}
\methodComment{
	Returns the name of this sequence.
}
\methodReturn{the name, or null if it has no name}
\closeMethod

\beginMethod{setName(String)}
\methodDeclaration{public synchronized void setName(String name)}
\methodComment{
	Sets the name of this sequence.
}
\closeMethod

\beginMethod{getSteps()}
\methodDeclaration{public synchronized int getSteps()}
\methodComment{
	Returns the number of steps in this sequence.
}
\closeMethod

\beginMethod{getStep(int)}
\methodDeclaration{public synchronized MeasurementStep getStep(int index)}
\methodComment{
	Returns the specified step from this sequence.
}
\methodParam{index}{the index of the step.}
\methodReturn{the specified step.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < 0 || index >= getSteps()).}
\closeMethod

\beginMethod{addStep(MeasurementStep)}
\methodDeclaration{public synchronized void addStep(MeasurementStep step)}
\methodComment{
	Appends a step to this sequence.
}
\methodParam{step}{the measurement step to be added.}
\methodThrows{NullPointerException}{if step is null.}
\closeMethod

\beginMethod{addStep(int,MeasurementStep)}
\methodDeclaration{public synchronized void addStep(int index, MeasurementStep step)}
\methodComment{
	Adds a step to the specified index of this sequence.
}
\methodParam{index}{the index to which the step will be added.}
\methodParam{step}{the measurement step to be added.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < 0 || index > getSteps()).}
\methodThrows{NullPointerException}{if step is null.}
\closeMethod

\beginMethod{removeStep(int)}
\methodDeclaration{public synchronized void removeStep(int index)}
\methodComment{
	Removes a step from this sequence.
}
\methodParam{index}{the index of the step to be removed.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < 0 || index >= getSteps()).}
\closeMethod


\beginClass{MeasurementStep}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementStep}
\classCreatedBy{Project, MeasurementSequencePanel}
\classUses{Project}
\classUses{MeasurementResult}
\classComment{
	A single step in a measurement sequence. Each step can include multiple measurements for improved precision. A step can have a different volume and mass than the related project, but by default the volume and mass of the project will be used. Only the project may change the state and results of a measurement step.
	
	All operations are thread-safe.
}
\closeClass

\beginField{project}
\fieldDeclaration{private Project project}
\fieldValue{null}
\fieldComment{
	The project that owns this step, or null if there is no owner.
}
\closeField

\beginField{state}
\fieldDeclaration{private State state}
\fieldValue{READY}
\fieldComment{
	Tells if this step has been completed or not, or if a measurement is still running.
}
\closeField

\beginField{timestamp}
\fieldDeclaration{private Date timestamp}
\fieldValue{null}
\fieldComment{
	The time the measurements were completed, or null if that has not yet happened.
}
\closeField

\beginField{stepValue}
\fieldDeclaration{private double stepValue}
\fieldValue{-1.0}
\fieldComment{
	The AF/Thermal value of this step, or a negative number if it has not been specified.
}
\closeField

\beginField{mass}
\fieldDeclaration{private double mass}
\fieldValue{-1.0}
\fieldComment{
	The mass of this step's sample, or a negative number to use the project's default mass.
}
\closeField

\beginField{volume}
\fieldDeclaration{private double volume}
\fieldValue{-1.0}
\fieldComment{
	The volume of this step's sample, or a negative number to use the project's default volume.
}
\closeField

\beginField{results}
\fieldDeclaration{private List<MeasurementResult> results}
\fieldValue{new ArrayList<MeasurementResult>()}
\fieldComment{
	The individual measurement results that are part of this measurement step.
}
\closeField

\beginMethod{MeasurementStep()}
\methodDeclaration{public MeasurementStep()}
\methodComment{
	Creates a blank measurement step.
}
\methodReturn{the created measurement step.}
\closeMethod

\beginMethod{MeasurementStep(Project)}
\methodDeclaration{public MeasurementStep(Project project)}
\methodComment{
	Creates a blank measurement step for a project.
}
\methodParam{project}{the project who is the owner of this step.}
\methodReturn{the created measurement step.}
\closeMethod

\beginMethod{MeasurementStep(Element)}
\methodDeclaration{public MeasurementStep(Element import)}
\methodComment{
	Creates a measurement step from the specified element.
}
\methodParam{import}{the element from which this step will be created.}
\methodReturn{the created measurement step.}
\methodThrows{IllegalArgumentException}{if the element was not in the right format.}
\closeMethod

\beginMethod{MeasurementStep(Element,Project)}
\methodDeclaration{public MeasurementStep(Element import, Project project)}
\methodComment{
	Creates a measurement step from the specified element for a project.
}
\methodParam{import}{the element from which this step will be created.}
\methodParam{project}{the project who is the owner of this step.}
\methodReturn{the created measurement step.}
\methodThrows{IllegalArgumentException}{if the element was not in the right format.}
\closeMethod

\beginMethod{getElement()}
\methodDeclaration{public synchronized Element getElement()}
\methodComment{
	Exports this step to a DOM element.
}
\closeMethod

\beginMethod{getProject()}
\methodDeclaration{public synchronized Project getProject()}
\methodComment{
	Returns the owner project of this step, or null if there is no owner.
}
\closeMethod

\beginMethod{getState()}
\methodDeclaration{public synchronized State getState()}
\methodComment{
	Tells if this step has been completed or not, or if a measurement is still running.
}
\closeMethod

\beginMethod{setState}
\methodDeclaration{void synchronized setState(State state)}
\methodComment{
	Sets the completion status of this step. Only the owner project may set the state.
}
\methodThrows{NullPointerException}{if state is null.}
\closeMethod

\beginMethod{getTimestamp()}
\methodDeclaration{public synchronized Date getTimestamp()}
\methodComment{
	Returns the time the measurements were completed, or null if that has not yet happened.
}
\closeMethod

\beginMethod{getStepValue()}
\methodDeclaration{public synchronized double getStepValue()}
\methodComment{
	Returns the AF/Thermal value of this step, or a negative number if it has not been specified.
}
\closeMethod

\beginMethod{setStepValue(double)}
\methodDeclaration{public synchronized void setStepValue(double stepValue)}
\methodComment{
	Sets the value of this step. A negative value will clear it.
}
\closeMethod

\beginMethod{getMass()}
\methodDeclaration{public synchronized double getMass()}
\methodComment{
	Returns the mass of this step's sample, or a negative number to use the project's default mass.
}
\closeMethod

\beginMethod{setMass(double)}
\methodDeclaration{public synchronized void setMass(double mass)}
\methodComment{
	Sets the mass of this step's sample. A negative value will clear it.
}
\closeMethod

\beginMethod{getVolume()}
\methodDeclaration{public synchronized double getVolume()}
\methodComment{
	Returns the volume of this step's sample, or a negative number to use the project's default volume.
}
\closeMethod

\beginMethod{setVolume(double)}
\methodDeclaration{public synchronized void setVolume(double volume)}
\methodComment{
	Sets the volume of this step's sample. A negative value will clear it.
}
\closeMethod

\beginMethod{updateTransforms()}
\methodDeclaration{synchronized void updateTransforms()}
\methodComment{
	Updates all of the measurement results with the owner project's transformation matrix.
}
\methodThrows{NullPointerException}{if this step is not owned by a project.}
\closeMethod

\beginMethod{getResults()}
\methodDeclaration{public synchronized int getResults()}
\methodComment{
	Returns the number of results in this step.
}
\closeMethod

\beginMethod{getResult(int)}
\methodDeclaration{public synchronized MeasurementResult getResult(int index)}
\methodComment{
	Returns a results from this step.
}
\methodParam{index}{the index of the result.}
\methodReturn{the specified result.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < 0 || index >= getResults()).}
\closeMethod

\beginMethod{addResult(MeasurementResult)}
\methodDeclaration{public synchronized void addResult(MeasurementResult result)}
\methodComment{
	Appends a measurement result to this step. The transformation matrix of the result will be updated automatically.
}
\methodParam{result}{the result to be added.}
\methodThrows{NullPointerException}{if result is null.}
\closeMethod


\beginClass{MeasurementStep.State}
\classPackage{ikayaki}
\classDeclaration{public enum State}
\classComment{
	The state of a measurement step. Options are READY, MEASURING, DONE\_RECENTLY and DONE.
}
\closeClass


\beginClass{MeasurementResult}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementResult}
\classCreatedBy{Magnetometer}
\classComment{
	A set of X, Y and Z values measured by the magnetometer. The raw XYZ values will be rotated in 3D space by using a transformation matrix. The project will set and update the transformation whenever its parameters are changed.
}
\closeClass

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
	The type of this result. Can be either a background noise measurement, or a sample in one of the four rotations.
}
\closeField

\beginField{rawTuple}
\fieldDeclaration{private Tuple3d rawTuple}
\fieldValue{new Tuple3d()}
\fieldComment{
	The unmodified measurements recieved from the squid.
}
\closeField

\beginField{tuple}
\fieldDeclaration{private Tuple3d tuple}
\fieldValue{new Tuple3d()}
\fieldComment{
	The measurements with the rotation and transformation matrix applied.
}
\closeField

\beginMethod{MeasurementResult(Type,double,double,double)}
\methodDeclaration{public MeasurementResult(Type type, double x, double y, double z}
\methodComment{
	Creates a new measurement result.
}
\methodParam{type}{the type (background or rotation) of this result.}
\methodParam{x}{the measured X coordinate value.}
\methodParam{y}{the measured Y coordinate value.}
\methodParam{z}{the measured Z coordinate value.}
\methodReturn{the created measurement result.}
\methodThrows{NullPointerException}{if type is null.}
\closeMethod

\beginMethod{MeasurementResult(Element)}
\methodDeclaration{public MeasurementResult(Element import)}
\methodComment{
	Creates a measurement result from the specified element. This will not apply the transformation matrix.
}
\methodParam{import}{the element from which this result will be created.}
\methodReturn{the created measurement result.}
\methodThrows{IllegalArgumentException}{if the element was not in the right format.}
\closeMethod

\beginMethod{getElement()}
\methodDeclaration{public Element getElement()}
\methodComment{
	Exports this result to a DOM element.
}
\closeMethod

\beginMethod{setTransform(Matrix3d)}
\methodDeclaration{void setTransform(Matrix3d transform)}
\methodComment{
	Applies a transformation matrix to this result.
}
\methodParam{transform}{the matrix to be applied.}
\methodThrows{NullPointerException}{if transform is null.}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public Type getType()}
\methodComment{
	Returns the type of this result (background or rotation).
}
\closeMethod

\beginMethod{getX()}
\methodDeclaration{public double getX()}
\methodComment{
	Returns the rotated and transformed X coordinate of this result.
}
\closeMethod

\beginMethod{getY()}
\methodDeclaration{public double getY()}
\methodComment{
	Returns the rotated and transformed Y coordinate of this result.
}
\closeMethod

\beginMethod{getZ()}
\methodDeclaration{public double getZ()}
\methodComment{
	Returns the rotated and transformed Z coordinate of this result.
}
\closeMethod

\beginMethod{getRawX()}
\methodDeclaration{public double getRawX()}
\methodComment{
	Returns the unmodified X coordinate of this result as recieved from the Squid.
}
\closeMethod

\beginMethod{getRawY()}
\methodDeclaration{public double getRawY()}
\methodComment{
	Returns the unmodified Y coordinate of this result as recieved from the Squid.
}
\closeMethod

\beginMethod{getRawZ()}
\methodDeclaration{public double getRawZ()}
\methodComment{
	Returns the unmodified Z coordinate of this result as recieved from the Squid.
}
\closeMethod


\beginClass{MeasurementResult.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The orientation of the sample when it was measured. Options are BG, DEG0, DEG90, DEG180 and DEG270.
}
\closeClass

\beginMethod{getName()}
\methodDeclaration{public String getName()}
\methodReturn{"BG", "0", "90", "180" or "270"}
\closeMethod

\beginMethod{rotate(Tuple3d)}
\methodDeclaration{public Tuple3d rotate(Tuple3d t)}
\methodComment{
	Rotates the raw XYZ values from the orientation of this object to that of DEG0. Rotating a BG or DEG0 will just copy the values directly.
}
\methodParam{t}{old values that need to be rotated.}
\methodReturn{a new object with the rotated values.}
\closeMethod

\beginMethod{rotate(Tuple3d,Tuple3d)}
\methodDeclaration{public Tuple3d rotate(Tuple3d t, Tuple3d result)}
\methodComment{
	Rotates the raw XYZ values from the orientation of this object to that of DEG0. Rotating a BG or DEG0 will just copy the values directly.
}
\methodParam{t}{old values that need to be rotated.}
\methodParam{result}{where the new values will be saved.}
\methodReturn{the same as the result parameter, or a new object if it was null.}
\closeMethod


\beginClass{MeasurementValue}
\classPackage{ikayaki}
\classDeclaration{public abstract class MeasurementValue<T>}
\classUses{MeasurementStep}
\classComment{
	Algorithms for calculating values from the measurements. A MeasurementValue object will be passed to the getValue() method of a project to retrieve the desired value.
}
\classPatterns{Strategy}
\closeClass

\beginField{X}
\fieldDeclaration{public static final MeasurementValue<Double> X}
\fieldComment{
	Calculates the average of all X components.
}
\closeField

\beginField{Y}
\fieldDeclaration{public static final MeasurementValue<Double> Y}
\fieldComment{
	Calculates the average of all Y components.
}
\closeField

\beginField{Z}
\fieldDeclaration{public static final MeasurementValue<Double> Z}
\fieldComment{
	Calculates the average of all Z components.
}
\closeField

\beginField{DECLINATION}
\fieldDeclaration{public static final MeasurementValue<Double> DECLINATION}
\fieldComment{
	Calculates the declination from the component averages.
}
\closeField

\beginField{INCLINATION}
\fieldDeclaration{public static final MeasurementValue<Double> INCLINATION}
\fieldComment{
	Calculates the inclination from the component averages.
}
\closeField

\beginField{MOMENT}
\fieldDeclaration{public static final MeasurementValue<Double> MOMENT}
\fieldComment{
	Calculates the length of the vector from the component averages.
}
\closeField

\beginField{REMANENCE}
\fieldDeclaration{public static final MeasurementValue<Double> REMANENCE}
\fieldComment{
	Calculates the remanence from the component averages and sample volume.
}
\closeField

\beginField{RELATIVE_REMANENCE}
\fieldDeclaration{public static final MeasurementValue<Double> RELATIVE\_REMANENCE}
\fieldComment{
	Calculates the remanence relative to the first measurement's remanence.
}
\closeField

\beginField{THETA63}
\fieldDeclaration{public static final MeasurementValue<Double> THETA63}
\fieldComment{
	Calculates the Theta 63 value from the measurement result set.
}
\closeField

\beginField{caption}
\fieldDeclaration{private String caption}
\fieldComment{
	A short name for the value.
}
\closeField

\beginField{unit}
\fieldDeclaration{private String unit}
\fieldComment{
	The unit of the value.
}
\closeField

\beginField{description}
\fieldDeclaration{private String description}
\fieldComment{
	A long description of the value.
}
\closeField

\beginMethod{MeasurementValue(String,String,String)}
\methodDeclaration{public MeasurementValue(String caption, String unit, String description)}
\methodComment{
	Creates a new measurement value.
}
\methodParam{caption}{a short name for the value.}
\methodParam{unit}{the unit of the value.}
\methodParam{description}{a long description of the value.}
\methodReturn{the created measurement value.}
\methodThrows{NullPointerException}{if any of the arguments is null.}
\closeMethod

\beginMethod{getValue(MeasurementStep)}
\methodDeclaration{abstract T getValue(MeasurementStep step)}
\methodComment{
	Calculates a specific value from a measurement step.
}
\methodParam{step}{the step from which the value will be calculated.}
\methodReturn{the calculated value, or null if it was not possible to calculate it.}
\methodThrows{NullPointerException}{if step is null.}
\closeMethod

\beginMethod{getCaption()}
\methodDeclaration{public String getCaption()}
\methodComment{
	Returns a short name for the value.
}
\closeMethod

\beginMethod{getUnit()}
\methodDeclaration{public String getUnit()}
\methodComment{
	Returns the unit of the value.
}
\closeMethod

\beginMethod{getDescription()}
\methodDeclaration{public String getDescription()}
\methodComment{
	Returns a long description of the value.
}
\closeMethod


\beginClass{ProjectEvent}
\classPackage{ikayaki}
\classDeclaration{public class ProjectEvent}
\classExtends{EventObject}
\classCreatedBy{Project}
\classComment{
	ProjectEvent is used to notify others about the state change of a project.
}
\closeClass

\beginField{project}
\fieldDeclaration{private Project project}
\fieldComment{
	The project that sent this event.
}
\closeField

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
	The type of event this is.
}
\closeField

\beginMethod{ProjectEvent(Project,Type)}
\methodDeclaration{public ProjectEvent(Project project, Type type)}
\methodComment{
	Creates a new project event.
}
\methodParam{project}{the project that sends this event.}
\methodParam{type}{the type of the event.}
\methodReturn{the created event.}
\methodThrows{NullPointerException}{if any of the arguments is null.}
\closeMethod

\beginMethod{getProject()}
\methodDeclaration{public Project getProject()}
\methodComment{
	Returns the project that sent this event.
}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public Type getType()}
\methodComment{
	Returns the type of this event.
}
\closeMethod


\beginClass{ProjectEvent.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The type of a project event. Options are STATE\_CHANGED, DATA\_CHANGED.
}
\closeClass


\beginClass{ProjectListener}
\classPackage{ikayaki}
\classDeclaration{public interface ProjectListener}
\classExtends{EventListener}
\classComment{
	Defines a listener for project events.
}
\closeClass

\beginMethod{projectUpdated(ProjectEvent)}
\methodDeclaration{public void projectUpdated(ProjectEvent event)}
\methodComment{
	Will be invoked whenever a project event happens.
}
\methodParam{event}{the event that happened.}
\closeMethod


\beginClass{MeasurementEvent}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementEvent}
\classExtends{EventObject}
\classCreatedBy{Project}
\classComment{
	MeasurementEvent is used to notify listeners about the stages of an ongoing measurement.
}
\closeClass

\beginField{project}
\fieldDeclaration{private Project project}
\fieldComment{
	The project whose measurement sent this event.
}
\closeField

\beginField{step}
\fieldDeclaration{private MeasurementStep step}
\fieldComment{
	The measurement that sent this event.
}
\closeField

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
	The type of event this is.
}
\closeField

\beginMethod{MeasurementEvent(Project,MeasurementStep,Type)}
\methodDeclaration{public MeasurementEvent(Project project, MeasurementStep step, Type type)}
\methodComment{
	Creates a new measurement event.
}
\methodParam{project}{the project whose measurement sent this event.}
\methodParam{step}{the measurement that sent this event.}
\methodParam{type}{the type of event this is.}
\methodReturn{the created event.}
\methodThrows{NullPointerException}{if any of the arguments is null.}
\closeMethod

\beginMethod{getProject()}
\methodDeclaration{public Project getProject()}
\methodComment{
	Returns the project whose measurement sent this event.
}
\closeMethod

\beginMethod{getStep()}
\methodDeclaration{public MeasurementStep getStep()}
\methodComment{
	Returns the measurement that sent this event.
}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public Type getType()}
\methodComment{
	Returns the type of event this is.
}
\closeMethod


\beginClass{MeasurementEvent.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The type of a measurement event. Options are STEP\_START, STEP\_END, STEP\_ABORTED, HANDLER\_MOVE, HANDLER\_ROTATE, HANDLER\_STOP, DEMAGNETIZE\_START, DEMAGNETIZE\_END, VALUE\_MEASURED.
}
\closeClass


\beginClass{MeasurementListener}
\classPackage{ikayaki}
\classDeclaration{public interface MeasurementListener}
\classExtends{EventListener}
\classComment{
	Defines a listener for measurement events.
}
\closeClass

\beginMethod{measurementUpdated(MeasurementEvent)}
\methodDeclaration{public void measurementUpdated(MeasurementEvent event)}
\methodComment{
	Will be invoked whenever a measurement event happens.
}
\methodParam{event}{the event that happened.}
\closeMethod


