
\beginClass{Project}
\classPackage{ikayaki}
\classDeclaration{public class Project}
\classCreatedBy{ProjectExplorerPanel}
\classUses{MeasurementSequence}
\classUses{MeasurementStep}
\classUses{MeasurementResult}
\classUses{MeasurementValue}
\classUses{Squid}
\classUses{RunQueue}
\classUses{ProjectEvent}
\classUses{MeasurementEvent}
\classComment{
	Represents a measurement project file. Project is responsible for managing and storing the data that is recieved from the magnetometer measurements. Any changes made to the project will be written to file regularly (autosave).
	
	Project is responsible for controlling the magnetometer through the SQUID API. Controlling the SQUID will be done in a private worker thread. Only one project at a time may access the SQUID.
	
	All operations are thread-safe.
}
\classPatterns{Facade}
\classEvent{On property change}{Autosaving will be invoked and the project written to file after a short delay.}
\classEvent{On measurement started/ended/paused/aborted}{ProjectEvent will be fired to all project listeners.}
\classEvent{On measurement subphase started/completed}{MeasurementEvent will be fired to all measurement listeners.}
\classEvent{On declination/inclination/volume changed}{The updated transformation matrix will be applied to all measurements and a ProjectEvent will be fired to all project listeners.}
\closeClass

\beginField{projectCache}
\fieldDeclaration{private static Hashtable<File,Project> projectCache}
\fieldComment{
	Caches the created and loaded Project objects to make sure that no more than one object will be created for each physical file.
}
\closeField

\beginField{file}
\fieldDeclaration{private File file}
\fieldComment{
	Location of the project file in the local file system. Autosaving will save the project to this file.
}
\closeField

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
	Type of the measurement project. This will affect which features of the project are enabled and disabled.
}
\closeField

\beginField{state}
\fieldDeclaration{private State state}
\fieldValue{IDLE}
\fieldComment{
	Current state of the measurements. If no measurement is running, then state is IDLE. Only one measurement may be running at a time.
}
\closeField

\beginField{squid}
\fieldDeclaration{private Squid squid}
\fieldValue{null}
\fieldComment{
	Pointer to the SQUID device interface, or null if this project is not its owner.
}
\closeField

\beginField{properties}
\fieldDeclaration{private Properties properties}
\fieldComment{
	Custom properties of this project stored in a map. The project is not interested in what properties are stored; it only saves them.
}
\closeField

\beginField{sequence}
\fieldDeclaration{private MeasurementSequence sequence}
\fieldComment{
	Measurement sequence of this project. In the beginning are all completed measurement steps, and in the end are planned measurement steps. Completed measurements may NOT be deleted.
}
\closeField

\beginField{strike}
\fieldDeclaration{private double strike}
\fieldValue{0.0}
\fieldComment{
	Strike of the sample. Will be used to create the transform matrix.
}
\closeField

\beginField{dip}
\fieldDeclaration{private double dip}
\fieldValue{0.0}
\fieldComment{
	Dip of the sample. Will be used to create the transform matrix.
}
\closeField

\beginField{sampleType}
\fieldDeclaration{private SampleType sampleType}
\fieldValue{CORE}
\fieldComment{
	Type of the sample. Will be used to create the transform matrix.
}
\closeField

\beginField{transform}
\fieldDeclaration{private Matrix3d transform}
\fieldValue{new Matrix3d()}
\fieldComment{
	Matrix for correcting the sample's orientation. The matrix will be updated whenever the strike, dip or sampleType is changed. After that the updated matrix will be applied to all measurements.
}
\closeField

\beginField{mass}
\fieldDeclaration{private double mass}
\fieldValue{-1.0}
\fieldComment{
	Mass of the sample, or a negative value if no mass is defined.
}
\closeField

\beginField{volume}
\fieldDeclaration{private double volume}
\fieldValue{-1.0}
\fieldComment{
	Volume of the sample, or a negative value if no volume is defined.
}
\closeField

\beginField{currentStep}
\fieldDeclaration{private MeasurementStep currentStep}
\fieldValue{null}
\fieldComment{
	Current measurement step, or null if no measurement is running.
}
\closeField

\beginField{listenerList}
\fieldDeclaration{private EventListenerList listenerList}
\fieldValue{new EventListenerList()}
\fieldComment{
	Listeners for this project.
}
\closeField

\beginField{autosaveQueue}
\fieldDeclaration{private RunQueue autosaveQueue}
\fieldValue{new RunQueue(500, true)}
\fieldComment{
	Scheduler for automatically writing the modified project to file after a short delay.
}
\closeField

\beginMethod{createCalibrationProject(File)}
\methodDeclaration{public static Project createCalibrationProject(File file)}
\methodComment{
	Creates a calibration project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createAFProject(File)}
\methodDeclaration{public static Project createAFProject(File file)}
\methodComment{
	Creates an AF project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createThellierProject(File)}
\methodDeclaration{public static Project createThellierProject(File file)}
\methodComment{
	Creates a thellier project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createThermalProject(File)}
\methodDeclaration{public static Project createThermalProject(File file)}
\methodComment{
	Creates a thermal project file.
}
\methodParam{file}{path for the new project file.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{createProject(File,Type)}
\methodDeclaration{private static Project createProject(File file, Type type)}
\methodComment{
	Creates a project file of the specified type. Ensures that the project file has been written to disk. Adds the created Project object to projectCache.
}
\methodParam{file}{path for the new project file.}
\methodParam{type}{type of the project.}
\methodReturn{the created project, or null if file was not writable.}
\closeMethod

\beginMethod{loadProject(File)}
\methodDeclaration{public static Project loadProject(File file)}
\methodComment{
	Loads a saved project file. If the file has already been loaded, will return a reference to the existing Project object.
}
\methodParam{file}{project file to be loaded.}
\methodReturn{the loaded project, or null if file is not a valid project file or it was not readable.}
\closeMethod

\beginMethod{closeProject(Project)}
\methodDeclaration{public static boolean closeProject(Project project)}
\methodComment{
	Ensures that the project file is saved and frees the resources taken by the project. A project should not be used after it has been closed -- any further use of the object is undefined (probably will create NullPointerExceptions). The closed project is removed from the projectCache. A project can not be closed if it has a measurement running.
}
\methodParam{project}{project to be closed.}
\methodReturn{true if the project has been closed, false if a measurement is running and the project can not be closed.}
\methodThrows{NullPointerException}{if the project is null.}
\closeMethod

\beginMethod{Project(File,Type)}
\methodDeclaration{private Project(File file, Type type)}
\methodComment{
	Creates a new project of the specified type. This constructor will not write to file, so the user of this method should call the saveNow() method after the project is initialized.
}
\methodParam{file}{path for this project file. The file should exist (may be empty) and be writable, but this constructor will not check it.}
\methodParam{type}{type of the project.}
\methodReturn{the created project.}
\closeMethod

\beginMethod{Project(File,Document)}
\methodDeclaration{private Project(File file, Document document)}
\methodComment{
	Creates a new project from the specified document. This constructor will assume that the specified file is the same from which the document was read.
}
\methodParam{file}{path for this project file. The file should be the same from which document was read and be writable, but this constructor will not check it.}
\methodParam{document}{the document from which this project will be created.}
\methodReturn{the created project.}
\methodThrows{IllegalArgumentException}{if the import data was not in the right format.}
\closeMethod

\beginMethod{getDocument()}
\methodDeclaration{public synchronized Document getDocument()}
\methodComment{
	Exports this project to a DOM document.
}
\closeMethod

\beginMethod{save()}
\methodDeclaration{public synchronized void save()}
\methodComment{
	Invokes autosaving. This method will schedule a saving operation and return. After this method has not been called for a short while, the project will be written to file.
}
\closeMethod

\beginMethod{saveNow()}
\methodDeclaration{public void saveNow()}
\methodComment{
	Writes this project to its project file and waits for the operation to complete.
	
	(NOTE: Synchronizing is done inside the method)
}
\methodThrows{IOException}{if there was an error when writing to file.}
\closeMethod

\beginMethod{getFile()}
\methodDeclaration{public synchronized File getFile()}
\methodComment{
	Returns the project file of this project.
}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public synchronized Type getType()}
\methodComment{
	Returns the type of this project.
}
\closeMethod

\beginMethod{getState()}
\methodDeclaration{public synchronized State getState()}
\methodComment{
	Returns the current measurement state of this project.
}
\closeMethod

\beginMethod{getName()}
\methodDeclaration{public synchronized String getName()}
\methodComment{
	Returns the name of this project. The name is equal to the name of the project file without the file extension.
}
\closeMethod

\beginMethod{getTimestamp()}
\methodDeclaration{public synchronized Date getTimestamp()}
\methodComment{
	Returns the timestamp of the last completed measurement. This is usually less than the last modified date of the file, because this is not affected by changing the project's properties.
}
\closeMethod

\beginMethod{getSquid()}
\methodDeclaration{private synchronized Squid getSquid()}
\methodComment{
	Returns the Squid if this project is its owner, otherwise returns null.
}
\closeMethod

\beginMethod{setSquid(Squid)}
\methodDeclaration{public synchronized boolean setSquid(Squid squid)}
\methodComment{
	Sets this project the owner of the Squid. Uses the setOwner() method of the specified Squid.
	
	Only one project may own the Squid at a time. The Squid must be first detached with "setSquid(null)" from its owner before it can be given to another project. Detaching the Squid is possible only when the project's state is IDLE.
}
\methodParam{squid}{pointer to the SQUID interface, or null to detach this project from it.}
\methodReturn{true if the operation was completed, false if the Squid has another owner or a measurement is running (in which case nothing was changed).}
\closeMethod

\beginMethod{getProperty(String)}
\methodDeclaration{public synchronized String getProperty(String key)}
\methodComment{
	Returns a project information property.
}
\methodParam{key}{the key which is associated with the property.}
\methodReturn{the specified property, or an empty String if the property is not set.}
\closeMethod

\beginMethod{setProperty(String,String)}
\methodDeclaration{public synchronized void setProperty(String key, String value)}
\methodComment{
	Sets a project information property.
}
\methodParam{key}{the key which is associated with the property.}
\methodParam{value}{new value for the property, or null to remove the property.}
\closeMethod

\beginMethod{getStrike()}
\methodDeclaration{public synchronized double getStrike()}
\methodComment{
	Returns the strike of the sample.
}
\closeMethod

\beginMethod{setStrike(double)}
\methodDeclaration{public synchronized void setStrike(double strike)}
\methodComment{
	Sets the strike of the sample and calls updateTransforms().
}
\closeMethod

\beginMethod{getDip()}
\methodDeclaration{public synchronized double getDip()}
\methodComment{
	Returns the dip of the sample.
}
\closeMethod

\beginMethod{setDip(double)}
\methodDeclaration{public synchronized void setDip(double dip)}
\methodComment{
	Sets the dip of the sample and calls updateTransforms().
}
\closeMethod

\beginMethod{getSampleType()}
\methodDeclaration{public synchronized SampleType getSampleType()}
\methodComment{
	Returns the type of the sample.
}
\closeMethod

\beginMethod{setSampleType(SampleType)}
\methodDeclaration{public synchronized void setSampleType(SampleType sampleType)}
\methodComment{
	Sets the type of the sample and calls updateTransforms().
}
\methodThrows{NullPointerException}{if sampleType is null.}
\closeMethod

\beginMethod{getTransform()}
\methodDeclaration{synchronized Matrix3d getTransform()}
\methodComment{
	Returns the current transformation matrix for the sample. For performance reasons, this method returns a reference to the internal data structure and not a copy of it.
	
	WARNING!!! Absolutely NO modification of the data contained in this matrix should be made -- if any such manipulation is necessary, it should be done on a copy of the matrix returned rather than the matrix itself.
}
\methodReturn{reference to the transformation matrix.}
\closeMethod

\beginMethod{updateTransforms()}
\methodDeclaration{private synchronized void updateTransforms()}
\methodComment{
	Recalculates the transformation matrix and updates all measurements. This method is called automatically by the setStrike(), setDip() and setSampleType() methods.
}
\closeMethod

\beginMethod{getMass()}
\methodDeclaration{public synchronized double getMass()}
\methodComment{
	Returns the mass of the sample.
}
\methodReturn{mass of the sample, or a negative number if no mass is specified.}
\closeMethod

\beginMethod{setMass(double)}
\methodDeclaration{public synchronized void setMass(double mass)}
\methodComment{
	Sets the mass of the sample.
}
\methodParam{mass}{mass of the sample, or a negative number to clear it.}
\closeMethod

\beginMethod{getVolume()}
\methodDeclaration{public synchronized double getVolume()}
\methodComment{
	Returns the volume of the sample.
}
\methodReturn{volume of the sample, or a negative number if no volume is specified.}
\closeMethod

\beginMethod{setVolume(double)}
\methodDeclaration{public synchronized void setVolume(double volume)}
\methodComment{
	Sets the volume of the sample.
}
\methodParam{volume}{volume of the sample, or a negative number to clear it.}
\closeMethod

\beginMethod{addProjectListener(ProjectListener)}
\methodDeclaration{public synchronized void addProjectListener(ProjectListener l)}
\methodComment{
	Adds a ProjectListener to the project.
}
\methodParam{l}{the listener to be added.}
\closeMethod

\beginMethod{removeProjectListener(ProjectListener)}
\methodDeclaration{public synchronized void removeProjectListener(ProjectListener l)}
\methodComment{
	Removes a ProjectListener from the project.
}
\methodParam{l}{the listener to be removed}
\closeMethod

\beginMethod{fireProjectEvent(ProjectEvent.Type)}
\methodDeclaration{private synchronized void fireProjectEvent(ProjectEvent.Type type)}
\methodComment{
	Notifies all listeners that have registered for ProjectEvents.
}
\methodParam{type}{type of the event.}
\closeMethod

\beginMethod{addMeasurementListener}
\methodDeclaration{public synchronized void addMeasurementListener(MeasurementListener l)}
\methodComment{
	Adds a MeasurementListener to the project.
}
\methodParam{l}{the listener to be added.}
\closeMethod

\beginMethod{removeMeasurementListener}
\methodDeclaration{public synchronized void removeMeasurementListener(MeasurementListener l)}
\methodComment{
	Removes a MeasurementListener from the project.
}
\methodParam{l}{the listener to be removed}
\closeMethod

\beginMethod{fireMeasurementEvent(MeasurementStep,MeasurementEvent.Type)}
\methodDeclaration{private synchronized void fireMeasurementEvent(MeasurementStep step, MeasurementEvent.Type type)}
\methodComment{
	Notifies all listeners that have registered for MeasurementEvents.
}
\methodParam{step}{the measurement step that has generated the event.}
\methodParam{type}{the type of the event.}
\closeMethod

\beginMethod{addSequence(MeasurementSequence}
\methodDeclaration{public synchronized void addSequence(MeasurementSequence sequence)}
\methodComment{
	Appends a sequence to this project's sequence. Only the stepValues will be copied from the specified sequence and added as new steps to this project.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{sequence}{the measurement sequence to be added.}
\methodThrows{NullPointerException}{if sequence is null.}
\closeMethod

\beginMethod{copySequence(int,int)}
\methodDeclaration{public synchronized MeasurementSequence copySequence(int start, int end)}
\methodComment{
	Returns a copy of this project's sequence. Only the stepValues will be copied from this project's sequence. The returned sequence will have no name.
}
\methodParam{start}{index of the first step in the sequence.}
\methodParam{end}{index of the last step in the sequence. If end < start, then an empty sequence will be returned.}
\methodReturn{copy of the sequence with only stepValues and no results.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (start < 0 || end >= getSteps()).}
\closeMethod

\beginMethod{addStep(MeasurementStep)}
\methodDeclaration{public synchronized void addStep(MeasurementStep step)}
\methodComment{
	Appends a step to this project's sequence. Only the stepValue will be copied from the specified step and added as new steps to this project.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{step}{the measurement step to be added.}
\methodThrows{NullPointerException}{if step is null.}
\closeMethod

\beginMethod{addStep(int,MeasurementStep)}
\methodDeclaration{public synchronized void addStep(int index, MeasurementStep step)}
\methodComment{
	Adds a step to the specified index of this project's sequence. Only the stepValue will be copied from the specified step and added as new steps to this project.
	
	The index must be such, that the indices of the completed measurements will not change.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{index}{the index to which the step will be added.}
\methodParam{step}{the measurement step to be added.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < getCompletedSteps() || index > getSteps()).}
\methodThrows{NullPointerException}{if step is null.}
\closeMethod

\beginMethod{removeStep(int)}
\methodDeclaration{public synchronized void removeStep(int index)}
\methodComment{
	Removes a step from this project's sequence. Completed measurements can not be removed.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{index}{the index of the step to be removed.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < getCompletedSteps() || index >= getSteps()).}
\closeMethod

\beginMethod{removeStep(int,int)}
\methodDeclaration{public synchronized void removeStep(int start, int end)}
\methodComment{
	Removes a series of steps from this project's sequence. Completed measurements can not be removed.
	
	If isSequenceEditEnabled() is false, nothing will be done.
}
\methodParam{start}{the first index to be removed.}
\methodParam{end}{the last index to be removed. If end < start, no steps will be removed.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (start < getCompletedSteps() || end >= getSteps()).}
\closeMethod

\beginMethod{getSteps()}
\methodDeclaration{public synchronized int getSteps()}
\methodComment{
	Returns the number of steps in this project.
}
\closeMethod

\beginMethod{getCompletedSteps()}
\methodDeclaration{public synchronized int getCompletedSteps()}
\methodComment{
	Returns the number of completed steps in this project. Steps that are currently being measured, are included in this count. Completed steps are always first in the sequence.
}
\closeMethod

\beginMethod{getStep(int)}
\methodDeclaration{public synchronized MeasurementStep getStep(int index)}
\methodComment{
	Returns a step from the sequence.
}
\methodParam{index}{the index of the step.}
\methodReturn{the specified step.}
\methodThrows{IndexOutOfBoundsException}{if the index is out of range (index < 0 || index >= getSteps()).}
\closeMethod

\beginMethod{getCurrentStep()}
\methodDeclaration{public synchronized MeasurementStep getCurrentStep()}
\methodComment{
	Returns the step that is currently being measured.
}
\methodReturn{the currently measured step, or null if no measurement is active.}
\closeMethod

\beginMethod{getValue(int,MeasurementValue)}
\methodDeclaration{public synchronized <A> A getValue(int step, MeasurementValue<A> algorithm)}
\methodComment{
	Calculates and returns a value from a measurement step. The specified MeasurementValue's algorithm will be used and the results returned.
}
\methodParam{step}{the measurement step from which the value is calculated.}
\methodParam{algorithm}{the algorithm for calculating the desired value.}
\methodReturn{the value returned by the algorithm, or null if it was not possible to calculate it.}
\methodThrows{NullPointerException}{if algorithm is null.}
\closeMethod

\beginMethod{isDegaussingEnabled()}
\methodDeclaration{public synchronized boolean isDegaussingEnabled()}
\methodComment{
	Tells whether it is allowed to use the degausser in this project. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isSequenceEditEnabled()}
\methodDeclaration{public synchronized boolean isSequenceEditEnabled()}
\methodComment{
	Tells whether it is allowed to edit the sequence. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isManualControlEnabled()}
\methodDeclaration{public synchronized boolean isManualControlEnabled()}
\methodComment{
	Tells whether it is allowed to control the Squid manually. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isAutoStepEnabled()}
\methodDeclaration{public synchronized boolean isAutoStepEnabled()}
\methodComment{
	Tells whether it is allowed to do an auto step measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isSingleStepEnabled()}
\methodDeclaration{public synchronized boolean isSingleStepEnabled()}
\methodComment{
	Tells whether it is allowed to do a single step measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isPauseEnabled()}
\methodDeclaration{public synchronized boolean isPauseEnabled()}
\methodComment{
	Tells whether it is possible to pause the measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{isAbortEnabled()}
\methodDeclaration{public synchronized boolean isAbortEnabled()}
\methodComment{
	Tells whether it is possible to abort the measurement. The returned value depends on the type and state of this project.
}
\closeMethod

\beginMethod{doAutoStep()}
\methodDeclaration{public synchronized boolean doAutoStep()}
\methodComment{
	Starts an auto step measurement. Will do nothing if isAutoStepEnabled() is false.
	
	The measurement will run in its own thread, and this method will not wait for it to finish.
}
\methodReturn{true if the measurement was started, otherwise false.}
\closeMethod

\beginMethod{doSingleStep()}
\methodDeclaration{public synchronized boolean doSingleStep()}
\methodComment{
	Starts a single step measurement. Will do nothing if isSingleStepEnabled() is false.
	
	The measurement will run in its own thread, and this method will not wait for it to finish.
}
\methodReturn{true if the measurement was started, otherwise false.}
\closeMethod

\beginMethod{doPause()}
\methodDeclaration{public synchronized boolean doPause()}
\methodComment{
	Pauses the currently running measurement. A paused measurement will halt after it finishes the current measurement step. Will do nothing if isPauseEnabled() is false.
	
	This method will notify the measurement thread to pause, but will not wait for it to finish.
}
\methodReturn{true if the measurement will pause, otherwise false.}
\closeMethod

\beginMethod{doAbort()}
\methodDeclaration{public synchronized boolean doAbort()}
\methodComment{
	Aborts the currently running measurement. An aborted measurement will halt immediately, leave the handler where it was and enable manual control. Will do nothing if isAbortEnabled() is false.
	
	This method will notify the measurement thread to abort, but will not wait for it to finish.
}
\methodReturn{true if the measurement will abort, otherwise false.}
\closeMethod


\beginClass{Project.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The type of the project. Options are CALIBRATION, AF, THELLIER and THERMAL.
}
\closeClass


\beginClass{Project.State}
\classPackage{ikayaki}
\classDeclaration{public enum State}
\classComment{
	The state of the project's measurements. Options are IDLE, MEASURING, PAUSED, ABORTED.
}
\closeClass


\beginClass{MeasurementSequence}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementSequence}
\classCreatedBy{Project}
\classUses{MeasurementStep}
\classComment{
	A list of measurement steps. Steps can be added or removed from the sequence.
	
	All operations are thread-safe.
}
\closeClass

\beginField{name}
\fieldDeclaration{private String name}
\fieldValue{}
\fieldComment{
}
\closeField

\beginField{steps}
\fieldDeclaration{private List<MeasurementStep>}
\fieldValue{new ArrayList<MeasurementStep>()}
\fieldComment{
}
\closeField

\beginMethod{MeasurementSequence()}
\methodDeclaration{public MeasurementSequence()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{MeasurementSequence(String)}
\methodDeclaration{public MeasurementSequence(String name)}
\methodComment{
}
\methodParam{name}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{MeasurementSequence(Element)}
\methodDeclaration{public MeasurementSequence(Element import)}
\methodComment{
}
\methodParam{import}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{MeasurementSequence(Element,Project)}
\methodDeclaration{public MeasurementSequence(Element import, Project project)}
\methodComment{
}
\methodParam{import}{}
\methodParam{project}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getElement()}
\methodDeclaration{public synchronized Element getElement()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getName()}
\methodDeclaration{public synchronized String getName()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{setName(String)}
\methodDeclaration{public synchronized void setName(String name)}
\methodComment{
}
\methodParam{name}{}
\methodThrows{}{}
\closeMethod

\beginMethod{getSteps()}
\methodDeclaration{public synchronized int getSteps()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getStep(int)}
\methodDeclaration{public synchronized MeasurementStep getStep(int index)}
\methodComment{
}
\methodParam{index}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{addStep(MeasurementStep)}
\methodDeclaration{public synchronized void addStep(MeasurementStep step)}
\methodComment{
}
\methodParam{step}{}
\methodThrows{}{}
\closeMethod

\beginMethod{addStep(int,MeasurementStep)}
\methodDeclaration{public synchronized void addStep(int index, MeasurementStep step)}
\methodComment{
}
\methodParam{index}{}
\methodParam{step}{}
\methodThrows{}{}
\closeMethod

\beginMethod{removeStep(int)}
\methodDeclaration{public synchronized void removeStep(int index)}
\methodComment{
}
\methodParam{index}{}
\methodThrows{}{}
\closeMethod


\beginClass{MeasurementStep}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementStep}
\classCreatedBy{Project, MeasurementSequencePanel}
\classUses{Project}
\classUses{MeasurementResult}
\classComment{
	A single step in a measurement sequence. Each step can include multiple measurements for improved measurement precision. A step can have a different volume and mass than the related project, but by default the volume and mass of the project will be used. Only the project may change the state and results of a measurement step.
	
	All operations are thread-safe.
}
\closeClass

\beginField{project}
\fieldDeclaration{private Project project}
\fieldComment{
}
\closeField

\beginField{state}
\fieldDeclaration{private State state}
\fieldValue{READY}
\fieldComment{
}
\closeField

\beginField{timestamp}
\fieldDeclaration{private Date timestamp}
\fieldComment{
}
\closeField

\beginField{stepValue}
\fieldDeclaration{private double stepValue}
\fieldValue{-1.0}
\fieldComment{
}
\closeField

\beginField{mass}
\fieldDeclaration{private double mass}
\fieldValue{-1.0}
\fieldComment{
}
\closeField

\beginField{volume}
\fieldDeclaration{private double volume}
\fieldValue{-1.0}
\fieldComment{
}
\closeField

\beginField{results}
\fieldDeclaration{private List<MeasurementResult> results}
\fieldValue{new ArrayList<MeasurementResult>()}
\fieldComment{
}
\closeField

\beginMethod{MeasurementStep()}
\methodDeclaration{public MeasurementStep()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{MeasurementStep(Project)}
\methodDeclaration{public MeasurementStep(Project project)}
\methodComment{
}
\methodParam{project}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{MeasurementStep(Element)}
\methodDeclaration{public MeasurementStep(Element import)}
\methodComment{
}
\methodParam{import}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{MeasurementStep(Element,Project)}
\methodDeclaration{public MeasurementStep(Element import, Project project)}
\methodComment{
}
\methodParam{import}{}
\methodParam{project}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getElement()}
\methodDeclaration{public synchronized Element getElement()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getProject()}
\methodDeclaration{public synchronized Project getProject()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getState()}
\methodDeclaration{public synchronized State getState()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{setState}
\methodDeclaration{void synchronized setState(State state)}
\methodComment{
}
\methodParam{state}{}
\methodThrows{}{}
\closeMethod

\beginMethod{getTimestamp()}
\methodDeclaration{public synchronized Date getTimestamp()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getStepValue()}
\methodDeclaration{public synchronized double getStepValue()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{setStepValue(double)}
\methodDeclaration{public synchronized void setStepValue(double stepValue)}
\methodComment{
}
\methodParam{stepValue}{}
\methodThrows{}{}
\closeMethod

\beginMethod{getMass()}
\methodDeclaration{public synchronized double getMass()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{setMass(double)}
\methodDeclaration{public synchronized void setMass(double mass)}
\methodComment{
}
\methodParam{mass}{}
\methodThrows{}{}
\closeMethod

\beginMethod{getVolume()}
\methodDeclaration{public synchronized double getVolume()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{setVolume(double)}
\methodDeclaration{public synchronized void setVolume(double volume)}
\methodComment{
}
\methodParam{volume}{}
\methodThrows{}{}
\closeMethod

\beginMethod{updateTransforms()}
\methodDeclaration{synchronized void updateTransforms()}
\methodComment{
}
\methodThrows{}{}
\closeMethod

\beginMethod{getResults()}
\methodDeclaration{public synchronized int getResults()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getResult(int)}
\methodDeclaration{public synchronized MeasurementResult getResult(int index)}
\methodComment{
}
\methodParam{index}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{addResult(MeasurementResult)}
\methodDeclaration{public synchronized void addResult(MeasurementResult result)}
\methodComment{
}
\methodParam{result}{}
\methodThrows{}{}
\closeMethod


\beginClass{MeasurementStep.State}
\classPackage{ikayaki}
\classDeclaration{public enum State}
\classComment{
	The state of a measurement step. Options are READY, MEASURING, DONE\_RECENTLY and DONE.
}
\closeClass


\beginClass{MeasurementResult}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementResult}
\classCreatedBy{Magnetometer}
\classComment{
	A set of X, Y and Z values measured by the magnetometer. The raw XYZ values will be rotated in 3D space by using a transformation matrix. The project will set and update the transformation whenever its parameters are changed.
}
\closeClass

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
}
\closeField

\beginField{rawTuple}
\fieldDeclaration{private Tuple3d rawTuple}
\fieldValue{new Tuple3d()}
\fieldComment{
}
\closeField

\beginField{tuple}
\fieldDeclaration{private Tuple3d tuple}
\fieldValue{new Tuple3d()}
\fieldComment{
}
\closeField

\beginMethod{MeasurementResult(Type,double,double,double)}
\methodDeclaration{public MeasurementResult(Type type, double x, double y, double z}
\methodComment{
}
\methodParam{type}{}
\methodParam{x}{}
\methodParam{y}{}
\methodParam{z}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{MeasurementResult(Element)}
\methodDeclaration{public MeasurementResult(Element import)}
\methodComment{
}
\methodParam{import}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getElement()}
\methodDeclaration{public Element getElement()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{setTransform(Matrix3d)}
\methodDeclaration{void setTransform(Matrix3d transform)}
\methodComment{
}
\methodParam{transform}{}
\methodThrows{}{}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public Type getType()}
\methodComment{
}
\methodReturn{}
\closeMethod

\beginMethod{getX()}
\methodDeclaration{public double getX()}
\methodComment{
}
\methodReturn{}
\closeMethod

\beginMethod{getY()}
\methodDeclaration{public double getY()}
\methodComment{
}
\methodReturn{}
\closeMethod

\beginMethod{getZ()}
\methodDeclaration{public double getZ()}
\methodComment{
}
\methodReturn{}
\closeMethod

\beginMethod{getRawX()}
\methodDeclaration{public double getRawX()}
\methodComment{
}
\methodReturn{}
\closeMethod

\beginMethod{getRawY()}
\methodDeclaration{public double getRawY()}
\methodComment{
}
\methodReturn{}
\closeMethod

\beginMethod{getRawZ()}
\methodDeclaration{public double getRawZ()}
\methodComment{
}
\methodReturn{}
\closeMethod


\beginClass{MeasurementResult.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The orientation of the sample when it was measured. Options are BG, DEG0, DEG90, DEG180 and DEG270.
}
\closeClass

\beginMethod{getName()}
\methodDeclaration{public String getName()}
\methodReturn{"BG", "0", "90", "180" or "270"}
\closeMethod

\beginMethod{rotate(Tuple3d)}
\methodDeclaration{public Tuple3d rotate(Tuple3d t)}
\methodComment{
	Rotates the raw XYZ values from the orientation of this object to that of DEG0. Rotating a BG or DEG0 will just copy the values directly.
}
\methodParam{t}{Old values that need to be rotated}
\methodReturn{A new object with the rotated values.}
\closeMethod

\beginMethod{rotate(Tuple3d,Tuple3d)}
\methodDeclaration{public Tuple3d rotate(Tuple3d t, Tuple3d result)}
\methodComment{
	Rotates the raw XYZ values from the orientation of this object to that of DEG0. Rotating a BG or DEG0 will just copy the values directly.
}
\methodParam{t}{Old values that need to be rotated}
\methodParam{result}{Where the new values will be saved}
\methodReturn{The same as the result parameter, or a new object if it was null.}
\closeMethod


\beginClass{MeasurementValue}
\classPackage{ikayaki}
\classDeclaration{public abstract class MeasurementValue<T>}
\classUses{MeasurementStep}
\classComment{
	Algorithms for calculating values from the measurements. A MeasurementValue object will be passed to the getValue method of a project to retrieve the desired value.
}
\classPatterns{Strategy}
\closeClass

\beginField{X}
\fieldDeclaration{public static final MeasurementValue<Double> X}
\fieldComment{
}
\closeField

\beginField{Y}
\fieldDeclaration{public static final MeasurementValue<Double> Y}
\fieldComment{
}
\closeField

\beginField{Z}
\fieldDeclaration{public static final MeasurementValue<Double> Z}
\fieldComment{
}
\closeField

\beginField{DECLINATION}
\fieldDeclaration{public static final MeasurementValue<Double> DECLINATION}
\fieldComment{
}
\closeField

\beginField{INCLINATION}
\fieldDeclaration{public static final MeasurementValue<Double> INCLINATION}
\fieldComment{
}
\closeField

\beginField{MOMENT}
\fieldDeclaration{public static final MeasurementValue<Double> MOMENT}
\fieldComment{
}
\closeField

\beginField{REMANENCE}
\fieldDeclaration{public static final MeasurementValue<Double> REMANENCE}
\fieldComment{
}
\closeField

\beginField{RELATIVE_REMANENCE}
\fieldDeclaration{public static final MeasurementValue<Double> RELATIVE\_REMANENCE}
\fieldComment{
}
\closeField

\beginField{THETA63}
\fieldDeclaration{public static final MeasurementValue<Double> THETA63}
\fieldComment{
}
\closeField

\beginField{caption}
\fieldDeclaration{private String caption}
\fieldComment{
}
\closeField

\beginField{unit}
\fieldDeclaration{private String unit}
\fieldComment{
}
\closeField

\beginField{description}
\fieldDeclaration{private String description}
\fieldComment{
}
\closeField

\beginMethod{MeasurementValue(String,String,String)}
\methodDeclaration{public MeasurementValue(String caption, String unit, String description)}
\methodComment{
}
\methodParam{caption}{}
\methodParam{unit}{}
\methodParam{description}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getValue(MeasurementStep)}
\methodDeclaration{abstract T getValue(MeasurementStep step)}
\methodComment{
}
\methodParam{step}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getCaption()}
\methodDeclaration{public String getCaption()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getUnit()}
\methodDeclaration{public String getUnit()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getDescription()}
\methodDeclaration{public String getDescription()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod


\beginClass{ProjectEvent}
\classPackage{ikayaki}
\classDeclaration{public class ProjectEvent}
\classExtends{EventObject}
\classCreatedBy{Project}
\classComment{
	ProjectEvent is used to notify others about the state change of a project.
}
\closeClass

\beginField{project}
\fieldDeclaration{private Project project}
\fieldComment{
}
\closeField

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
}
\closeField

\beginMethod{ProjectEvent(Project,Type)}
\methodDeclaration{public ProjectEvent(Project project, Type type)}
\methodComment{
}
\methodParam{project}{}
\methodParam{type}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getProject()}
\methodDeclaration{public Project getProject()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public Type getType()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod


\beginClass{ProjectEvent.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The type of a project event. Options are STATE_CHANGED, DATA_CHANGED.
}
\closeClass


\beginClass{ProjectListener}
\classPackage{ikayaki}
\classDeclaration{public interface ProjectListener}
\classExtends{EventListener}
\classComment{
	Defines a listener for project events.
}
\closeClass

\beginMethod{projectUpdated(ProjectEvent)}
\methodDeclaration{public void projectUpdated(ProjectEvent event)}
\methodComment{
}
\methodParam{event}{}
\closeMethod


\beginClass{MeasurementEvent}
\classPackage{ikayaki}
\classDeclaration{public class MeasurementEvent}
\classExtends{EventObject}
\classCreatedBy{Project}
\classComment{
	MeasurementEvent is used to notify listeners about the stages of an ongoing measurement.
}
\closeClass

\beginField{project}
\fieldDeclaration{private Project project}
\fieldComment{
}
\closeField

\beginField{step}
\fieldDeclaration{private MeasurementStep step}
\fieldComment{
}
\closeField

\beginField{type}
\fieldDeclaration{private Type type}
\fieldComment{
}
\closeField

\beginMethod{MeasurementEvent(Project,MeasurementStep,Type)}
\methodDeclaration{public MeasurementEvent(Project project, MeasurementStep step, Type type)}
\methodComment{
}
\methodParam{project}{}
\methodParam{step}{}
\methodParam{type}{}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getProject()}
\methodDeclaration{public Project getProject()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getStep()}
\methodDeclaration{public MeasurementStep getStep()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod

\beginMethod{getType()}
\methodDeclaration{public Type getType()}
\methodComment{
}
\methodReturn{}
\methodThrows{}{}
\closeMethod


\beginClass{MeasurementEvent.Type}
\classPackage{ikayaki}
\classDeclaration{public enum Type}
\classComment{
	The type of a measurement event. Options are STEP_START, STEP_END, STEP_ABORTED, HANDLER_MOVE, HANDLER_ROTATE, HANDLER_STOP, DEMAGNETIZE_START, DEMAGNETIZE_END, VALUE_MEASURED.
}
\closeClass


\beginClass{MeasurementListener}
\classPackage{ikayaki}
\classDeclaration{public interface MeasurementListener}
\classExtends{EventListener}
\classComment{
	Defines a listener for measurement events.
}
\closeClass

\beginMethod{measurementUpdated(MeasurementEvent)}
\methodDeclaration{public void measurementUpdated(MeasurementEvent event)}
\methodComment{
}
\methodParam{event}{}
\closeMethod


